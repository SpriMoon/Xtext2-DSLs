grammar nl.dslmeinte.xtext.express.Express hidden(WHITESPACE, EMBEDDED_REMARK, TAIL_REMARK)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate express "http://www.dslmeinte.nl/xtext/express/Express"

Model:
	( types+=Type )+
	;


/*
 * +----+
 * | §7 |
 * +----+
 */

terminal WHITESPACE: (' '|'\t'|'\r'|'\n')+;

// §7.1.6.1 - embedded remark
terminal EMBEDDED_REMARK: '(*' -> '*)';
	// TODO  support nested remarks (§7.1.6.1)

// §7.1.6.2 - tail remark
terminal TAIL_REMARK: '--' !('\n'|'\r')* ('\r'? '\n')?;

terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	// TODO  find out whether ^ in ID is desirable

// §7.5

Literal:
	BinaryLiteral | IntegerLiteral | StringLiteral | LogicalLiteral // | RealLiteral 
	;

BinaryLiteral hidden():
	'%' ( bits+=('0'|'1') )+
	;

IntegerLiteral:
	value=INT
	;

terminal INT returns ecore::EInt: ('0'..'9')+;

StringLiteral:
	value=STRING
	;

terminal STRING	: 
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
	; 

LogicalLiteral:
	value=LogicalLiteralSyntax
	;

enum LogicalLiteralSyntax:
	false | true | unknown
	;


/*
 * +----+
 * | §8 |
 * +----+
 */

DataType:
	SimpleDataType | AggregationDataType // | NamedDataType | ConstructedDataType | GeneralizedDataType
	;

// §8.1

SimpleDataType:
	NumberDataType | RealDataType | IntegerDataType | LogicalDataType | BooleanDataType | StringDataType | BinaryDataType
	;

// (the unparametrized simple data types:)
NumberDataType:  {NumberDataType}  'number' ;
IntegerDataType: {IntegerDataType} 'integer';
LogicalDataType: {LogicalDataType} 'logical';
BooleanDataType: {BooleanDataType} 'boolean';

RealDataType:
	{RealDataType} 'real' ( '(' precision=INT ')' )?
	;
	// TODO  precision=numeric_expression

StringDataType:
	{StringDataType} 'string' ( '(' width=INT ')' fixed?='fixed'? )?
	;
	// TODO  width=numeric_expression

BinaryDataType:
	{BinaryDataType} 'binary' ( '(' width=INT ')' fixed?='fixed'? )?
	;
	// TODO  width=numeric_expression

// §8.2

AggregationDataType:
	ArrayDataType | ListDataType | BagDataType | SetDataType
	;

ArrayDataType:
	'array' '[' from=INT ':' to=INT ']' 'of' optional?='optional'? unique?='unique'? type=BaseType
	;
	// TODO  from,to=numeric_expression

ListDataType:
	'list' ( '[' from=INT ':' to=INT ']' )? 'of' unique?='unique'? type=BaseType
	;

BagDataType:
	'bag' ( '[' from=INT ':' to=INT ']' )? 'of' type=BaseType
	;

SetDataType:
	'set' ( '[' from=INT ':' to=INT ']' )? 'of' type=BaseType
	;

NamedDataType:
	Entity // | DefinedDataType
	;

// §8.4

ConstructedDataType:
	Enumeration | SelectDataType
	;

Enumeration:	// not using the 'DataType' postfix because 'Enumeration' already exudes the data type semantics
	'enumeration' 'of' '(' literals+=ID ( ',' literals+=ID )* ')'
	;

SelectDataType:
	'select' '(' types+=[NamedDataType] ( ',' types+=[NamedDataType] )* ')'
	;

// §8.6

BaseType:
	AggregationDataType | SimpleDataType | NamedDataType
	;

UnderlyingDataType:
	ConstructedDataType | AggregationDataType | SimpleDataType | TypeReference
	;

TypeReference:
	type=[NamedDataType]
	;

/*
 * +----+
 * | §9 |
 * +----+
 */

Type:
	TypeDecl | Entity
	;

// §9.1

TypeDecl:
	'type' name=ID '=' type=UnderlyingDataType ';' whereClause=WhereClause? 'end_type' ';'
	;

terminal WhereClause:
	"where" (. -> ';')
	;
	// FIXME  this is an island grammar-style solution to not explicitly parser where clauses (not it only "parses" one DomainRule)

// §9.2

Entity:		// not using the 'DataType' postfix because 'Entity' already exudes the data type semantics
	'entity' name=ID /* TODO  [ subsuper ] */';'
		explicitAttributesDecl+=ExplicitAttributeDecl
		// TODO  derive-clause?, inverse-clause?, unique-clause?
		whereClause=WhereClause?
	'end_entity' ';'
	;

Attribute:
	ExplicitAttributeDecl
	;

ExplicitAttributeDecl:
	decls+=AttributeDecl ( ',' decls+=AttributeDecl )* ':' optional?='optional'? type=BaseType ';'
	;

AttributeDecl:
	AttributeID | QualifiedAttributeID
	;

AttributeID: name=ID;

QualifiedAttributeID hidden():
	'self' '\\' entity=[Entity] '.' attribute=[Attribute]
	;

